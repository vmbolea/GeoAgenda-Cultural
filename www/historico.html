<!DOCTYPE html>
<html>
        <head>
          <title>GeoAgenda Cultural</title> 
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
          <meta name="description" content="TFM de Víctor Martínez Bolea (Noviembre 2020)">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <!-- enlace a Bootstrap v3.3.7 en directorio -->
          <link rel="stylesheet" href="js/bootstrap/css/bootstrap.min.css" >
          <!-- enlace a Bootstrap v3.3.7 en la nube -->
          <!--  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"> -->
          <!-- enlace a CSS de Leaflet  Leaflet 1.7.1 en el directorio -->
          <link rel="stylesheet" href="js/leaflet.css"/>
          <!-- enlace a CSS de Leaflet  Leaflet 1.7.1 en la nube -->
          <!--  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
          integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
          crossorigin=""/> -->
          <!-- enlace a los estilos de salida de datos css -->
          <link href="estilos/style_out.css" rel="stylesheet" type="text/css" />              
        </head>
        </head>
        <body>
          <!-- barra de navegación superior fija -->
          <nav class="navbar navbar-default navbar-fixed-top"> 
            <div class="container">
              <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">GeoAgenda Cultural</a>
              </div>
      <div id="navbar" class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
            <li><a href='index.html'>Volver al visor principal</a></li> <!-- botón para volver al visor principal -->
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Análisis <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li class="dropdown-header">Ratio</li> <!-- tipo de análisis sobre ratio -->
                <li><input type="radio" id="ratiodistrito"  name= "analisis" checked> Por distrito</li> <!-- botón tipo de análisis -->
                <li class="dropdown-header">Eventos</li> <!-- tipo de análisis sobre eventos -->
                <li><input type="radio" id="eventosdistrito"  name= "analisis" > Por distrito &nbsp;</li> <!-- botón tipo de análisis -->
                <li><input type="radio" id="eventossectores"  name= "analisis" > Por sectores &nbsp;</li><!-- botón tipo de análisis -->
                <li><input type="radio" id="eventosheat" name= "analisis" > Mapa de calor &nbsp;</li><!-- botón tipo de análisis -->
                <li role="separator" class="divider"></li>
                <li class="dropdown-header">Conexiones</li> <!-- tipo de análisis sobre conexiones -->
                <li><input type="radio" id="conexiondistrito" name= "analisis" > Por distrito &nbsp;</li> <!-- botón tipo de análisis -->
                <li><input type="radio" id="conexionsectores"  name= "analisis" > Por sectores &nbsp;</li> <!-- botón tipo de análisis -->
                <li><input type="radio" id="conexionheat" name= "analisis" > Mapa de calor &nbsp;</li> <!-- botón tipo de análisis -->
              </ul>
            </li>     
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Descargas <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href='https://libregeo.unizar.es/geoserver/evento/ows?service=WFS&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=evento%3Aevento&amp'>Eventos</a></li>
                <li role="separator" class="divider"></li>
                <li><a href='https://libregeo.unizar.es/geoserver/evento/ows?service=WFS&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=evento%3Aconexion&amp'>Conexiones</a></li>
              </ul>
            </li>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
    <!-- inicio contenedor del mapa -->
    <div id="container" class="container-fluid">

      <div  id="maphis"></div>
      
    </div>
        </body>
         <!-- enlace a jquery-3.5.1 en el directorio -->
         <script src="js/jquery-3.5.1.min.js" type="text/javascript"></script>
         <!-- enlace a jquery-3.5.1 en la nube -->
           <!-- <script src="https://code.jquery.com/jquery-3.5.1.js" integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=" crossorigin="anonymous"></script>-->
         <!-- enlace a Bootstrap v3.3.7 en la nube -->
           <script src=js\bootstrap\js\bootstrap.min.js type="text/javascript"></script>
         <!-- enlace a Bootstrap v3.3.7 en la nube -->
           <!-- <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script> -->               
         <!-- enlace a JavaScript de Leaflet 1.7.1 en el directorio -->
           <script src="js/leaflet.js"></script>
         <!-- enlace a JavaScript de Leaflet 1.7.1 en la nube -->
           <!-- <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>-->
          <!-- enlace a extensión de mapa de calor de Leaflet en el directorio -->
           <script src="js/leaflet-heat.js"></script>
           <!-- enlace a Turf.js   en el directorio -->
           <script src="js/turf.min.js" charset="utf-8"></script>
         <!-- enlace a Turf.js en la nube -->
           <!--  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script> -->
           <!-- enlace a la capa de distritos en directorio-->
           <script src="layers\distritos_zgz_2017.js"></script>
          <script type="text/javascript">
          
        // definición de la variable del mapa
          var visor = L.map('maphis').setView([41.66, -0.88], 11); // clase l.map con referencia al id del contenedor y niveles de zoom

        // definición de la imagen del mapa base de OSM  añadida al mapa 
            var osmUrl ='http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'; // variable con url del mapa base
            var osmAttrib='&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors' // variable con la atribución
            var osm = new L.TileLayer(osmUrl, {attribution: osmAttrib}); // variable con la capa creada a partir de url y atribución
             osm.addTo(visor); // añadir capa al mapa

         // definición de la imagen escala  
         L.control.scale({ // clase leaflet de escala
              position: 'topright', // posición de la escala
              imperial: false}) // escala métrica
            .addTo(visor); // añadir al mapa

        // definición de la url sobre la capa evento del geoserver
        var evento = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
            var parametros_ev = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
               typeName: 'evento:evento', // nombre de la capa
              outputFormat: 'application/json'};// formato de salida
          var parametros_evento = L.Util.extend(parametros_ev); //cración de url para los parámetros     
          var URL_evento = evento + L.Util.getParamString(parametros_evento); // definición de la url con la unión del directorio principal + los parámetros
        
        // definición de la url sobre la capa conexion del geoserver
        var conexion = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
          var parametros_con = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
              typeName: 'conexion', // nombre de la capa
              outputFormat: 'application/json'}; // formato de salida             
            var parametros_conexion = L.Util.extend(parametros_con); //cración de url para los parámetros   
            var URL_conexion = evento + L.Util.getParamString(parametros_conexion); // definición de la url con la unión del directorio principal + los parámetros

        // definición del control de genérico
        info = L.control( {position: 'bottomleft'}); // declaración de variable + posición sobre mapa

        // definición del cuadro de información sobre análisis
        info.onAdd = function (visor) { // añadir función al control
          this._div = L.DomUtil.create('div', 'info'); // creación de la estructura del contenido
          this.update("<b>Cargando...</b>"); // creación de la estructura contenido genércio
          return this._div; // devuelve la estructura del contenido
        }; 
        // definición de la función que actualizada el contenido del cuadro de información
        info.update = function (value) { // añadir función al control
          this._div.innerHTML = value;}; // valor a añadir

        // añadir el cuadro de información al mapa
        info.addTo(visor);

        // función de definición de estilo
        function styleGenerator(feature) {
        return { // devuelve el estilo
            weight: 1, // peso
            color: 'white', // color
            fillOpacity: 0.6, // opacidad
            fillColor: getColour(feature.properties.ratio)};	// el color viene definido por la función getcolour
                                        } // termina función de definición de estilo

        // función de definición de color
        function getColour(e) { // devuelve el color en función del valor del análisis
            // se condiciona el color al valor del análisis
            if (e > 50){
              return '#800026'; // devuelve color
            } else if (e > 30) {
              return '#BD0026'; // devuelve color
            } else if (e > 15) {
              return '#E31A1C'; // devuelve color
            } else if (e > 10) {
              return '#FC4E2A'; // devuelve color
            } else if (e > 5) {
              return '#FD8D3C'; // devuelve color
            } else if (e > 1) {
              return '#FEB24C'; // devuelve color
            } else if (e > 0.1) {
              return '#FED976'; // devuelve color
            } else if (e > 0.01) {
              return '#FFEDA0'; // devuelve color
            } else {
              return "#DDDDDD";}}// termina función de definición de color

        // función de definición de los eventos al pasar el cursor sobre el mapa
        function setEvents(feature, layer) {
        //se añade el listado de eventos
        layer.on({ // función sobre capa
          mouseover: highlightFeature, // resaltar polígono
          mouseout: resetFeature, // resetear estilo
        }); // se cierra la función sobre capa
        } // se cierra función de definición de los eventos al pasar el cursor sobre el mapa

        // Función para dar estilo al polígono seleccionado y alimentar de contenido al cuadro de información
        function highlightFeature(e) {	// función para definir evento resaltar polígono
        // Definición de e.target que es el polígono seleccionado
          const feature = e.target;
            feature.setStyle({fillColor: 'yellow',}); // resaltar con color amarillo
          //Actualización del cuadro de información
          info.update("Desde el distrito de <b>" + feature.feature.properties.title +"</b> se localizan <b>"+ feature.feature.properties.ratio.toFixed(2)+"</b>"+" conexiones por cada evento");
          } // se cierra función de dar estilo al polígono seleccionado y alimentar de contenido el cuadro de información
        
         // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
         function resetFeature(e) {	// función para resetear estilo
          // Definición de e.target que es el polígono seleccionado
          const feature = e.target;
          ratioDistrito.resetStyle(feature);  // resetear el estilo del polígono de la capa
          // actualización del cuadro de información
          info.update("Poner el cursor sobre un distrito");
          } // se cierra función

          // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa evento definida más arriba.        
          $.getJSON(URL_evento,function(e){  // función de llamada 
          var eventos = []; // definición array vacío
                  for (var i = 0; i < e.features.length; i++) { // iteración sobre los datos cargados
                      eventos.push(e.features[i].geometry.coordinates); // se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          eventosCollection = turf.featureCollection(eventos);   // se crea una colección de turf a partir del array rellenado
           // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa conexiones definida más arriba.
          $.getJSON(URL_conexion,function(c){ // función de llamada 
          var conexion = []; // definición array vacío
				          for (var i = 0; i < c.features.length; i++) { // iteración sobre los datos cargados
                      conexion.push(c.features[i].geometry.coordinates);// se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          conexionCollection = turf.featureCollection(conexion); // se crea una colección de turf a partir del array rellenado
          // definición de la clase geojson de leaflet con los datos de los distritos almacenados en el servidor
          distritos = L.geoJson(distritosData); // datos de los distritos
          // definición de variables usadas en iteración
          var eventosWithin; // variable vacía (eventos dentro de)
          var conexionWithin; // variable vacía (conexiones dentro de)
          var distritosturf = []; // definición array vacío
                for (var i = 0; i < distritosData.features.length; i++) { // iteración sobre las geometrías de los distritos
                  distritosnombre = distritosData.features[i].properties.title; // variable con los nombres de los distritos
                  conexionWithin = turf.pointsWithinPolygon(conexionCollection, distritosData.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (evento) + los distritos
                  eventosWithin = turf.pointsWithinPolygon(eventosCollection, distritosData.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (conexion) + los distritos
                  distritosturf.push( turf.polygon(distritosData.features[i].geometry.coordinates, // se cargan las geometrias con los datos derivados de las funciones de turf 
                    { eventos: eventosWithin.features.length, // eventos por polígono
                      conexion: conexionWithin.features.length, // conexiones por polígono
                      ratio:conexionWithin.features.length/eventosWithin.features.length, // ratio conexiones/distrito por distrito
                      title: distritosnombre  }));  // nombre de los distritos
                                                                          };// se cierra la iteración sobre los datos con el array rellenado
          var polygonCollection = turf.featureCollection(distritosturf); // se crea una colección de turf a partir del array rellenado
          
          // definición de la clase geojson definitiva
          ratioDistrito = L.geoJson(polygonCollection, {	// alimentada con la colección de turf de los datos de las geometrías de los distritos + las recurrencias
                    style: styleGenerator, // estilo por función
                    onEachFeature: setEvents // para cada feature función             
                  }); // se cierra la definición de la clase geojson definitiva
                  // se define la variable que contiene un grupo de capas      
            myData =  L.layerGroup([]); // variable con grupo de capas vacío
            myData.addLayer(ratioDistrito); // se añade la capa ratioDistrito previamente declarada y rellenada
            myData.addTo(visor); // se añade el grupo de capas al mapa
                }); // se cierra la petición sobre la capa conexion     
              }); // se cierra la petición sobre la capa evento

  // Aquí comienza la definición del comportamiento de los eventos sobre los elementos "botones" de la barra de navegación

          // Evento para botón ratio por distritos
          document.getElementById("ratiodistrito").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
          // definición de la url sobre la capa evento del geoserver
        var evento = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
            var parametros_ev = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
               typeName: 'evento:evento', // nombre de la capa
              outputFormat: 'application/json'};// formato de salida
          var parametros_evento = L.Util.extend(parametros_ev); //cración de url para los parámetros     
          var URL_evento = evento + L.Util.getParamString(parametros_evento); // definición de la url con la unión del directorio principal + los parámetros
        
        // definición de la url sobre la capa conexion del geoserver
        var conexion = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
          var parametros_con = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
              typeName: 'conexion', // nombre de la capa
              outputFormat: 'application/json'}; // formato de salida             
            var parametros_conexion = L.Util.extend(parametros_con); //cración de url para los parámetros   
            var URL_conexion = evento + L.Util.getParamString(parametros_conexion); // definición de la url con la unión del directorio principal + los parámetros
        
        // función de definición de estilo
        function styleGenerator(feature) {
        return { // devuelve el estilo
            weight: 1, // peso
            color: 'white', // color
            fillOpacity: 0.6, // opacidad
            fillColor: getColour(feature.properties.ratio)};	// el color viene definido por la función getcolour
                                        } // termina función de definición de estilo

        // función de definición de color
        function getColour(e) { // devuelve el color en función del valor del análisis
            // se condiciona el color al valor del análisis
            if (e > 50){
              return '#800026'; // devuelve color
            } else if (e > 30) {
              return '#BD0026'; // devuelve color
            } else if (e > 15) {
              return '#E31A1C'; // devuelve color
            } else if (e > 10) {
              return '#FC4E2A'; // devuelve color
            } else if (e > 5) {
              return '#FD8D3C'; // devuelve color
            } else if (e > 1) {
              return '#FEB24C'; // devuelve color
            } else if (e > 0.1) {
              return '#FED976'; // devuelve color
            } else if (e > 0.01) {
              return '#FFEDA0'; // devuelve color
            } else {
              return "#DDDDDD";}}// termina función de definición de color

        // función de definición de los eventos al pasar el cursor sobre el mapa
        function setEvents(feature, layer) {
        //se añade el listado de eventos
        layer.on({ // función sobre capa
          mouseover: highlightFeature, // resaltar polígono
          mouseout: resetFeature, // resetear estilo
        }); // se cierra la función sobre capa
        } // se cierra función de definición de los eventos al pasar el cursor sobre el mapa

        // Función para dar estilo al polígono seleccionado y alimentar de contenido al cuadro de información
        function highlightFeature(e) {	// función para definir evento resaltar polígono
        // Definición de e.target que es el polígono seleccionado
          const feature = e.target;
            feature.setStyle({fillColor: 'yellow',}); // resaltar con color amarillo
          //Actualización del cuadro de información
          info.update("Desde el distrito de <b>" + feature.feature.properties.title +"</b> se localizan <b>"+ feature.feature.properties.ratio.toFixed(2)+"</b>"+" conexiones por cada evento");
          } // se cierra función de dar estilo al polígono seleccionado y alimentar de contenido el cuadro de información
        
         // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
         function resetFeature(e) {	// función para resetear estilo
          // Definición de e.target que es el polígono seleccionado
          const feature = e.target;
          ratioDistrito.resetStyle(feature);  // resetear el estilo del polígono de la capa
          // actualización del cuadro de información
          info.update("Poner el cursor sobre un distrito");
          } // se cierra función

          // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa evento definida más arriba.        
          $.getJSON(URL_evento,function(e){  // función de llamada 
          var eventos = []; // definición array vacío
                  for (var i = 0; i < e.features.length; i++) { // iteración sobre los datos cargados
                      eventos.push(e.features[i].geometry.coordinates); // se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          eventosCollection = turf.featureCollection(eventos);   // se crea una colección de turf a partir del array rellenado
           // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa conexiones definida más arriba.
          $.getJSON(URL_conexion,function(c){ // función de llamada 
          var conexion = []; // definición array vacío
				          for (var i = 0; i < c.features.length; i++) { // iteración sobre los datos cargados
                      conexion.push(c.features[i].geometry.coordinates);// se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          conexionCollection = turf.featureCollection(conexion); // se crea una colección de turf a partir del array rellenado
          // definición de la clase geojson de leaflet con los datos de los distritos almacenados en el servidor
          distritos = L.geoJson(distritosData); // datos de los distritos
          // definición de variables usadas en iteración
          var eventosWithin; // variable vacía (eventos dentro de)
          var conexionWithin; // variable vacía (conexiones dentro de)
          var distritosturf = []; // definición array vacío
                for (var i = 0; i < distritosData.features.length; i++) { // iteración sobre las geometrías de los distritos
                  distritosnombre = distritosData.features[i].properties.title; // variable con los nombres de los distritos
                  conexionWithin = turf.pointsWithinPolygon(conexionCollection, distritosData.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (evento) + los distritos
                  eventosWithin = turf.pointsWithinPolygon(eventosCollection, distritosData.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (conexion) + los distritos
                  distritosturf.push( turf.polygon(distritosData.features[i].geometry.coordinates, // se cargan las geometrias con los datos derivados de las funciones de turf 
                    { eventos: eventosWithin.features.length, // eventos por polígono
                      conexion: conexionWithin.features.length, // conexiones por polígono
                      ratio:conexionWithin.features.length/eventosWithin.features.length, // ratio conexiones/distrito por distrito
                      title: distritosnombre  }));  // nombre de los distritos
                                                                          };// se cierra la iteración sobre los datos con el array rellenado
          var polygonCollection = turf.featureCollection(distritosturf); // se crea una colección de turf a partir del array rellenado
          
          // definición de la clase geojson definitiva
          ratioDistrito = L.geoJson(polygonCollection, {	// alimentada con la colección de turf de los datos de las geometrías de los distritos + las recurrencias
                    style: styleGenerator, // estilo por función
                    onEachFeature: setEvents // para cada feature función             
                  }); // se cierra la definición de la clase geojson definitiva
                  // se define la variable que contiene un grupo de capas      
            myData =  L.layerGroup([]); // variable con grupo de capas vacío
            myData.addLayer(ratioDistrito); // se añade la capa ratioDistrito previamente declarada y rellenada
            myData.addTo(visor); // se añade el grupo de capas al mapa
                }); // se cierra la petición sobre la capa conexion     
              }); // se cierra la petición sobre la capa evento
            }); // se cierra evento para botón ratio por distritos

        // Evento para botón eventos por distrito
        document.getElementById("eventosdistrito").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
          // definición de la url sobre la capa evento del geoserver
        var evento = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
            var parametros_ev = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
               typeName: 'evento:evento', // nombre de la capa
              outputFormat: 'application/json'};// formato de salida
          var parametros_evento = L.Util.extend(parametros_ev); //cración de url para los parámetros     
          var URL_evento = evento + L.Util.getParamString(parametros_evento); // definición de la url con la unión del directorio principal + los parámetros
        
          // función de definición de estilo
        function styleGenerator(feature) {
        return { // devuelve el estilo
            weight: 1, // peso
            color: 'white', // color
            fillOpacity: 0.6, // opacidad
            fillColor: getColour(feature.properties.eventos)};	// el color viene definido por la función getcolour
                                        } // termina función de definición de estilo
          // función de definición de color
        function getColour(e) { // devuelve el color en función del valor del análisis
            // se condiciona el color al valor del análisis
            if (e > 128){
              return '#800026'; // devuelve color
            } else if (e > 64) {
              return '#BD0026'; // devuelve color
            } else if (e > 32) {
              return '#E31A1C'; // devuelve color
            } else if (e > 16) {
              return '#FC4E2A'; // devuelve color
            } else if (e > 8) {
              return '#FD8D3C'; // devuelve color
            } else if (e > 4) {
              return '#FEB24C'; // devuelve color
            } else if (e > 2) {
              return '#FED976'; // devuelve color
            } else if (e > 0) {
              return '#FFEDA0'; // devuelve color
            } else {
              return "#DDDDDD";}}// termina función de definición de color 

          // función de definición de los eventos al pasar el cursor sobre el mapa
            function setEvents(feature, layer) {
            //se añade el listado de eventos
            layer.on({ // función sobre capa
              mouseover: highlightFeature, // resaltar polígono
              mouseout: resetFeature, // resetear estilo
            }); // se cierra la función sobre capa
            } // se cierra función de definición de los eventos al pasar el cursor sobre el mapa

            // Función para dar estilo al polígono seleccionado y alimentar de contenido al cuadro de información
            function highlightFeature(e) {	// función para definir evento resaltar polígono
            // Definición de e.target que es el polígono seleccionado
              const feature = e.target;
                feature.setStyle({fillColor: 'yellow',}); // resaltar con color amarillo
              //Actualización del cuadro de información
            info.update("Distrito de <b>" + feature.feature.properties.title +": </b> "+ feature.feature.properties.eventos + " eventos");
                                          } // se cierra función de dar estilo al polígono seleccionado y alimentar de contenido el cuadro de información
        
        // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
        function resetFeature(e) {	// función para resetear estilo
         // Definición de e.target que es el polígono seleccionado
         const feature = e.target;
         eventosDistrito.resetStyle(feature);  // resetear el estilo del polígono de la capa
         // actualización del cuadro de información
         info.update("Poner el cursor sobre un distrito");
         } // se cierra función

          // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa evento definida más arriba.        
          $.getJSON(URL_evento,function(e){  // función de llamada 
          var eventos = []; // definición array vacío
                  for (var i = 0; i < e.features.length; i++) { // iteración sobre los datos cargados
                      eventos.push(e.features[i].geometry.coordinates); // se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          pointsCollection = turf.featureCollection(eventos);   // se crea una colección de turf a partir del array rellenado
          // definición de la clase geojson de leaflet con los datos de los distritos almacenados en el servidor
          distritos = L.geoJson(distritosData); // datos de los distritos
          // definición de variables usadas en iteración
          var pointsWithin; // variable vacía (eventos dentro de)
          var distritosturf = []; // definición array vacío
                for (var i = 0; i < distritosData.features.length; i++) { // iteración sobre las geometrías de los distritos
                  distritosnombre = distritosData.features[i].properties.title; // variable con los nombres de los distritos
                  pointsWithin = turf.pointsWithinPolygon(pointsCollection, distritosData.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (evento) + los distritos
                  distritosturf.push( turf.polygon(distritosData.features[i].geometry.coordinates, // se cargan las geometrias con los datos derivados de las funciones de turf 
              { eventos: pointsWithin.features.length, // cantidad de eventos por cada geometría
                title: distritosnombre  })); // nombre de cada polígono
                                                                          };// se cierra la iteración sobre los datos con el array rellenado
              var polygonCollection = turf.featureCollection(distritosturf); // se crea una colección de turf a partir del array rellenado
  
          // definición de la clase geojson definitiva
          eventosDistrito = L.geoJson(polygonCollection, {	// alimentada con la colección de turf de los datos de las geometrías de los distritos + las recurrencias
                    style: styleGenerator, // estilo por función
                    onEachFeature: setEvents // para cada feature función             
                  }); // se cierra la definición de la clase geojson definitiva
                  // se define la variable que contiene un grupo de capas      
            myData =  L.layerGroup([]); // variable con grupo de capas vacío
            myData.addLayer(eventosDistrito); // se añade la capa ratioDistrito previamente declarada y rellenada
            myData.addTo(visor); // se añade el grupo de capas al mapa   
              }); // se cierra la petición sobre la capa evento
            }); // se cierra evento para botón eventos por distritos

        // Evento para botón conexión por distrito
        document.getElementById("conexiondistrito").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
         // definición de la url sobre la capa conexion del geoserver
         var conexion = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
          var parametros_con = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
              typeName: 'conexion', // nombre de la capa
              outputFormat: 'application/json'}; // formato de salida             
            var parametros_conexion = L.Util.extend(parametros_con); //cración de url para los parámetros   
            var URL_conexion = evento + L.Util.getParamString(parametros_conexion); // definición de la url con la unión del directorio principal + los parámetros
            // función de definición de estilo
        function styleGenerator(feature) {
        return { // devuelve el estilo
            weight: 1, // peso
            color: 'white', // color
            fillOpacity: 0.6, // opacidad
            fillColor: getColour(feature.properties.conexion)};	// el color viene definido por la función getcolour
                                        } // termina función de definición de estilo
          // función de definición de color
        function getColour(e) { // devuelve el color en función del valor del análisis
            // se condiciona el color al valor del análisis
            if (e > 128){
              return '#800026'; // devuelve color
            } else if (e > 64) {
              return '#BD0026'; // devuelve color
            } else if (e > 32) {
              return '#E31A1C'; // devuelve color
            } else if (e > 16) {
              return '#FC4E2A'; // devuelve color
            } else if (e > 8) {
              return '#FD8D3C'; // devuelve color
            } else if (e > 4) {
              return '#FEB24C'; // devuelve color
            } else if (e > 2) {
              return '#FED976'; // devuelve color
            } else if (e > 0) {
              return '#FFEDA0'; // devuelve color
            } else {
              return "#DDDDDD";}}// termina función de definición de color 

          // función de definición de los eventos al pasar el cursor sobre el mapa
            function setEvents(feature, layer) {
            //se añade el listado de eventos
            layer.on({ // función sobre capa
              mouseover: highlightFeature, // resaltar polígono
              mouseout: resetFeature, // resetear estilo
            }); // se cierra la función sobre capa
            } // se cierra función de definición de los eventos al pasar el cursor sobre el mapa

            // Función para dar estilo al polígono seleccionado y alimentar de contenido al cuadro de información
            function highlightFeature(e) {	// función para definir evento resaltar polígono
            // Definición de e.target que es el polígono seleccionado
              const feature = e.target;
                feature.setStyle({fillColor: 'yellow',}); // resaltar con color amarillo
              //Actualización del cuadro de información
              info.update("Distrito de <b>" + feature.feature.properties.title +"</b>: <b>"+ feature.feature.properties.conexion +"</b> conexiones");
                                        } // se cierra función de dar estilo al polígono seleccionado y alimentar de contenido el cuadro de información
        
        // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
        function resetFeature(e) {	// función para resetear estilo
         // Definición de e.target que es el polígono seleccionado
         const feature = e.target;
         conexionDistrito.resetStyle(feature);  // resetear el estilo del polígono de la capa
         // actualización del cuadro de información
         info.update("Poner el cursor sobre un distrito");
         } // se cierra función
          // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa conexion definida más arriba.        
          $.getJSON(URL_conexion,function(e){  // función de llamada 
          var conexion = []; // definición array vacío
                  for (var i = 0; i < e.features.length; i++) { // iteración sobre los datos cargados
                      conexion.push(e.features[i].geometry.coordinates); // se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          pointsCollection = turf.featureCollection(conexion);   // se crea una colección de turf a partir del array rellenado
          // definición de la clase geojson de leaflet con los datos de los distritos almacenados en el servidor
          distritos = L.geoJson(distritosData); // datos de los distritos
          // definición de variables usadas en iteración
          var pointsWithin; // variable vacía (conexiones dentro de)
          var distritosturf = []; // definición array vacío
                for (var i = 0; i < distritosData.features.length; i++) { // iteración sobre las geometrías de los distritos
                  distritosnombre = distritosData.features[i].properties.title; // variable con los nombres de los distritos
                  pointsWithin = turf.pointsWithinPolygon(pointsCollection, distritosData.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (evento) + los distritos
                  distritosturf.push( turf.polygon(distritosData.features[i].geometry.coordinates, // se cargan las geometrias con los datos derivados de las funciones de turf 
              { conexion: pointsWithin.features.length, // cantidad de eventos por cada geometría
                title: distritosnombre  })); // nombre de cada polígono
                                                                          };// se cierra la iteración sobre los datos con el array rellenado
              var polygonCollection = turf.featureCollection(distritosturf); // se crea una colección de turf a partir del array rellenado
  
          // definición de la clase geojson definitiva
          conexionDistrito = L.geoJson(polygonCollection, {	// alimentada con la colección de turf de los datos de las geometrías de los distritos + las recurrencias
                    style: styleGenerator, // estilo por función
                    onEachFeature: setEvents // para cada feature función             
                  }); // se cierra la definición de la clase geojson definitiva
                  // se define la variable que contiene un grupo de capas      
            myData =  L.layerGroup([]); // variable con grupo de capas vacío
            myData.addLayer(conexionDistrito); // se añade la capa ratioDistrito previamente declarada y rellenada
            myData.addTo(visor); // se añade el grupo de capas al mapa   
              }); // se cierra la petición sobre la capa conexion
            }); // se cierra evento para botón conexion por distritos

     // Evento para botón evento por sector
      document.getElementById("eventossectores").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
      // definición de la url sobre la capa evento del geoserver
      var evento = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
            var parametros_ev = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
               typeName: 'evento:evento', // nombre de la capa
              outputFormat: 'application/json'};// formato de salida
          var parametros_evento = L.Util.extend(parametros_ev); //cración de url para los parámetros     
          var URL_evento = evento + L.Util.getParamString(parametros_evento); // definición de la url con la unión del directorio principal + los parámetros
          // función de definición de estilo
        function styleGenerator(feature) {
        return { // devuelve el estilo
            weight: 1, // peso
            color: 'white', // color
            fillOpacity: 0.6, // opacidad
            fillColor: getColour(feature.properties.eventos)};	// el color viene definido por la función getcolour
                                        } // termina función de definición de estilo
          // función de definición de color
        function getColour(e) { // devuelve el color en función del valor del análisis
            // se condiciona el color al valor del análisis
            if (e > 128){
              return '#800026'; // devuelve color
            } else if (e > 64) {
              return '#BD0026'; // devuelve color
            } else if (e > 32) {
              return '#E31A1C'; // devuelve color
            } else if (e > 16) {
              return '#FC4E2A'; // devuelve color
            } else if (e > 8) {
              return '#FD8D3C'; // devuelve color
            } else if (e > 4) {
              return '#FEB24C'; // devuelve color
            } else if (e > 2) {
              return '#FED976'; // devuelve color
            } else if (e > 0) {
              return '#FFEDA0'; // devuelve color
            } else {
              return "#DDDDDD";}}// termina función de definición de color 

          // función de definición de los eventos al pasar el cursor sobre el mapa
            function setEvents(feature, layer) {
            //se añade el listado de eventos
            layer.on({ // función sobre capa
              mouseover: highlightFeature, // resaltar polígono
              mouseout: resetFeature, // resetear estilo
            }); // se cierra la función sobre capa
            } // se cierra función de definición de los eventos al pasar el cursor sobre el mapa

            // Función para dar estilo al polígono seleccionado y alimentar de contenido al cuadro de información
            function highlightFeature(e) {	// función para definir evento resaltar polígono
            // Definición de e.target que es el polígono seleccionado
              const feature = e.target;
                feature.setStyle({fillColor: 'yellow',}); // resaltar con color amarillo
              //Actualización del cuadro de información
              info.update("El sector seleccionado tiene <b>"+ feature.feature.properties.eventos +"</b> eventos");
                                        } // se cierra función de dar estilo al polígono seleccionado y alimentar de contenido el cuadro de información
        
        // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
        function resetFeature(e) {	// función para resetear estilo
         // Definición de e.target que es el polígono seleccionado
         const feature = e.target;
         evan.resetStyle(feature);  // resetear el estilo del polígono de la capa
         // actualización del cuadro de información
         info.update("Poner el cursor sobre un sector");
         } // se cierra función
         // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa evento definida más arriba.        
         $.getJSON(URL_evento,function(e){  // función de llamada 
          var eventos = []; // definición array vacío
                  for (var i = 0; i < e.features.length; i++) { // iteración sobre los datos cargados
                      eventos.push(e.features[i].geometry.coordinates); // se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          pointsCollection = turf.featureCollection(eventos);   // se crea una colección de turf a partir del array rellenado

          // definición de las variables con los ángulos de los sectores
          var center =[-0.87734,41.65606] // posición del ayuntamiento de Zaragoza
          var radius = 10; //radio de los sectores en kilometros por default
          var n = 0; // norte
          var ne = 45; // noreste
          var e = 90; // este
          var se = 135; // sureste
          var s = 180; // sur
          var so = -135; // suroeste
          var o = -90; // oeste
          var no = -45; // noroeste
        // declaración de variables con los sectores
        var sectornne = turf.sector(center, radius, n, ne, {sector: 'Norte/Noreste'});
        var sectornee = turf.sector(center, radius, ne, e, {sector: 'Noreste/Este'});
        var sectorese = turf.sector(center, radius, e, se, {sector: 'Este/Sureste'});
        var sectorses = turf.sector(center, radius, se, s, {sector: 'Sureste/Sur'});
        var sectornsso = turf.sector(center, radius, s, so,{sector: 'Sur/Suroeste'});
        var sectornsoo = turf.sector(center, radius, so, o, {sector: 'Suroeste/Oeste'});
        var sectornono = turf.sector(center, radius, o, no, {sector: 'Oeste/Noroeste'});
        var sectornnon = turf.sector(center, radius, no, n, {sector: 'Nortoeste/Norte'});
        var sectores = turf.featureCollection([sectornne,sectornee,sectorese,sectorses,sectornsso,sectornsoo,sectornono,sectornnon]); // se crea una colección de turf con los sectores
        // definición de variables usadas en iteración
        var pointsWithin; // variable vacía (eventos dentro de)
        var an = []; // definición array vacío
                for (var i = 0; i < sectores.features.length; i++) { // iteración sobre las geometrías de sectores
                  sectoresnombre = sectores.features[i].properties.sector; // variable con los nombres de sectores
                  pointsWithin =turf.pointsWithinPolygon(pointsCollection, sectores.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (evento) + los sectores
                  an.push( turf.polygon(sectores.features[i].geometry.coordinates, // se cargan las geometrias con los datos derivados de las funciones de turf 
              { eventos: pointsWithin.features.length, // cantidad de eventos por cada geometría
                title: sectoresnombre  })); // nombre de cada sector
                                                                          };// se cierra la iteración sobre los datos con el array rellenado
            var polygonCollection = turf.featureCollection(an); // se crea una colección de turf a partir del array rellenado
  
            // definición de la clase geojson definitiva
           evan = L.geoJson(polygonCollection, {	// alimentada con la colección de turf de los datos de las geometrías de los sectores + las recurrencias
                      style: styleGenerator, // estilo por función
                      onEachFeature: setEvents // para cada feature función             
                    }); // se cierra la definición de la clase geojson definitiva
                    // se define la variable que contiene un grupo de capas      
              myData =  L.layerGroup([]); // variable con grupo de capas vacío
              myData.addLayer(evan); // se añade la capa ratioDistrito previamente declarada y rellenada
              myData.addTo(visor); // se añade el grupo de capas al mapa   
                }); // se cierra la petición sobre la capa evento
              }); // se cierra evento para botón eventos por sector


        // Evento para botón conexión por sector
        document.getElementById("conexionsectores").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
         // definición de la url sobre la capa conexion del geoserver
         var conexion = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
          var parametros_con = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
              typeName: 'conexion', // nombre de la capa
              outputFormat: 'application/json'}; // formato de salida             
            var parametros_conexion = L.Util.extend(parametros_con); //cración de url para los parámetros   
            var URL_conexion = evento + L.Util.getParamString(parametros_conexion); // definición de la url con la unión del directorio principal + los parámetros
            // función de definición de estilo
        function styleGenerator(feature) {
        return { // devuelve el estilo
            weight: 1, // peso
            color: 'white', // color
            fillOpacity: 0.6, // opacidad
            fillColor: getColour(feature.properties.conexion)};	// el color viene definido por la función getcolour
                                        } // termina función de definición de estilo
          // función de definición de color
        function getColour(e) { // devuelve el color en función del valor del análisis
            // se condiciona el color al valor del análisis
            if (e > 128){
              return '#800026'; // devuelve color
            } else if (e > 64) {
              return '#BD0026'; // devuelve color
            } else if (e > 32) {
              return '#E31A1C'; // devuelve color
            } else if (e > 16) {
              return '#FC4E2A'; // devuelve color
            } else if (e > 8) {
              return '#FD8D3C'; // devuelve color
            } else if (e > 4) {
              return '#FEB24C'; // devuelve color
            } else if (e > 2) {
              return '#FED976'; // devuelve color
            } else if (e > 0) {
              return '#FFEDA0'; // devuelve color
            } else {
              return "#DDDDDD";}}// termina función de definición de color 

          // función de definición de los eventos al pasar el cursor sobre el mapa
            function setEvents(feature, layer) {
            //se añade el listado de eventos
            layer.on({ // función sobre capa
              mouseover: highlightFeature, // resaltar polígono
              mouseout: resetFeature, // resetear estilo
            }); // se cierra la función sobre capa
            } // se cierra función de definición de los eventos al pasar el cursor sobre el mapa

            // Función para dar estilo al polígono seleccionado y alimentar de contenido al cuadro de información
            function highlightFeature(e) {	// función para definir evento resaltar polígono
            // Definición de e.target que es el polígono seleccionado
              const feature = e.target;
                feature.setStyle({fillColor: 'yellow',}); // resaltar con color amarillo
              //Actualización del cuadro de información
              info.update("El sector seleccionado tiene <b>"+ feature.feature.properties.conexion +"</b> eventos");
                                        } // se cierra función de dar estilo al polígono seleccionado y alimentar de contenido el cuadro de información
        
        // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
        function resetFeature(e) {	// función para resetear estilo
         // Definición de e.target que es el polígono seleccionado
         const feature = e.target;
         coan.resetStyle(feature);  // resetear el estilo del polígono de la capa
         // actualización del cuadro de información
         info.update("Poner el cursor sobre un sector");
         } // se cierra función
         // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa evento definida más arriba.        
         $.getJSON(URL_conexion,function(e){  // función de llamada 
          var conexiones = []; // definición array vacío
                  for (var i = 0; i < e.features.length; i++) { // iteración sobre los datos cargados
                      conexiones.push(e.features[i].geometry.coordinates); // se cargan las geometrias de los datos como puntos turf 
                    }; // se cierra la iteración sobre los datos con el array rellenado
          pointsCollection = turf.featureCollection(conexiones);   // se crea una colección de turf a partir del array rellenado
          // definición de las variables con los ángulos de los sectores
          var center =[-0.87734,41.65606] // posición del ayuntamiento de Zaragoza
          var radius = 10; //radio de los sectores en kilometros por default
          var n = 0; // norte
          var ne = 45; // noreste
          var e = 90; // este
          var se = 135; // sureste
          var s = 180; // sur
          var so = -135; // suroeste
          var o = -90; // oeste
          var no = -45; // noroeste
        // declaración de variables con los sectores
        var sectornne = turf.sector(center, radius, n, ne, {sector: 'Norte/Noreste'});
        var sectornee = turf.sector(center, radius, ne, e, {sector: 'Noreste/Este'});
        var sectorese = turf.sector(center, radius, e, se, {sector: 'Este/Sureste'});
        var sectorses = turf.sector(center, radius, se, s, {sector: 'Sureste/Sur'});
        var sectornsso = turf.sector(center, radius, s, so,{sector: 'Sur/Suroeste'});
        var sectornsoo = turf.sector(center, radius, so, o, {sector: 'Suroeste/Oeste'});
        var sectornono = turf.sector(center, radius, o, no, {sector: 'Oeste/Noroeste'});
        var sectornnon = turf.sector(center, radius, no, n, {sector: 'Nortoeste/Norte'});
        var sectores = turf.featureCollection([sectornne,sectornee,sectorese,sectorses,sectornsso,sectornsoo,sectornono,sectornnon]); // se crea una colección de turf con los sectores
        // definición de variables usadas en iteración
        var pointsWithin; // variable vacía (eventos dentro de)
        var an = []; // definición array vacío
                for (var i = 0; i < sectores.features.length; i++) { // iteración sobre las geometrías de sectores
                  sectoresnombre = sectores.features[i].properties.sector; // variable con los nombres de sectores
                  pointsWithin =turf.pointsWithinPolygon(pointsCollection, sectores.features[i]); // alimentación de la variable vacía con la función de turf sobre la colección de puntos (evento) + los sectores
                  an.push( turf.polygon(sectores.features[i].geometry.coordinates, // se cargan las geometrias con los datos derivados de las funciones de turf 
              { conexion: pointsWithin.features.length, // cantidad de eventos por cada geometría
                title: sectoresnombre  })); // nombre de cada sector
                                                                          };// se cierra la iteración sobre los datos con el array rellenado
            var polygonCollection = turf.featureCollection(an); // se crea una colección de turf a partir del array rellenado
  
            // definición de la clase geojson definitiva
           coan = L.geoJson(polygonCollection, {	// alimentada con la colección de turf de los datos de las geometrías de los sectores + las recurrencias
                      style: styleGenerator, // estilo por función
                      onEachFeature: setEvents // para cada feature función             
                    }); // se cierra la definición de la clase geojson definitiva
                    // se define la variable que contiene un grupo de capas      
              myData =  L.layerGroup([]); // variable con grupo de capas vacío
              myData.addLayer(coan); // se añade la capa ratioDistrito previamente declarada y rellenada
              myData.addTo(visor); // se añade el grupo de capas al mapa   
                }); // se cierra la petición sobre la capa conexion
              }); // se cierra evento para botón conexiones por sector

    // Evento para botón conexión por mapa de calor
     document.getElementById("conexionheat").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
          var conexion = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
          var parametros_con = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
              typeName: 'conexion', // nombre de la capa
              outputFormat: 'application/json'}; // formato de salida             
            var parametros_conexion = L.Util.extend(parametros_con); //cración de url para los parámetros   
            var URL_conexion = evento + L.Util.getParamString(parametros_conexion); // definición de la url con la unión del directorio principal + los parámetros
        // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
        function resetFeature(e) {	// función para resetear estilo
         // Definición de e.target que es el polígono seleccionado
         const feature = e.target;
         heatcon.resetStyle(feature);  // resetear el estilo del polígono de la capa
         // actualización del cuadro de información
         info.update("Mapa de densidad de las conexiones a la plataforma");
         } // se cierra función
            // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa conexion definida más arriba.        
         $.getJSON(URL_conexion,function(e){  // función de llamada 
          var locations = e.features.map(function(e) { // definición de variable con función
          var location = e.geometry.coordinates.reverse(); // las geometrías
          location.push(3); // impulsadas
          return location; // devuelve el valor a location
          }); // se cierra la definición de la variable con función
        // definición de la clase heat layer definitiva
        var heatcon = L.heatLayer(locations, { radius: 10, blur: 15, minOpacity:0.2 }); // clase heat layer alimentada con radio,difuminación y opacidad
        myData.addLayer(heatcon);// se añade la capa heatcon previamente declarada y rellenada       
         myData.addTo(visor); // se añade el grupo de capas al mapa   
                }); // se cierra la petición sobre la capa conexion
              }); // se cierra evento para botón conexiones por mapa de calor

        // Evento para botón conexión por mapa de calor
        document.getElementById("eventosheat").addEventListener('click', function(event) {// si se presiona el botón con el id
          myData.clearLayers(); // el grupo de capas se limpia
          visor.removeLayer(myData); // se borra el grupo de capas sobre el mapa
		    // definición de la url sobre la capa evento del geoserver
        var evento = 'https://libregeo.unizar.es/geoserver/evento/ows'; // directorio al espacio de trabajo del geoserver
            var parametros_ev = {// definición de los parámetros de la consulta
               service: 'WFS', // tipo de servicio
               version: '2.17.1', // versión geoserver
               request: 'GetFeature', // tipo de petición
               typeName: 'evento:evento', // nombre de la capa
              outputFormat: 'application/json'};// formato de salida
          var parametros_evento = L.Util.extend(parametros_ev); //cración de url para los parámetros     
          var URL_evento = evento + L.Util.getParamString(parametros_evento); // definición de la url con la unión del directorio principal + los parámetros
        // Función para resetear estilo cuando otro polígono es seleccionado y el contenido del cuadro de información
        function resetFeature(e) {	// función para resetear estilo
         // Definición de e.target que es el polígono seleccionado
         const feature = e.target;
         heatevento.resetStyle(feature);  // resetear el estilo del polígono de la capa
         // actualización del cuadro de información
         info.update("Mapa de densidad de los eventos en la plataforma");
         } // se cierra función
        // llamada para cargar los datos mediante una solicitud GET HTTP a la url de capa evento definida más arriba.        
        $.getJSON(URL_evento,function(e){  // función de llamada 
          var locations = e.features.map(function(e) { // definición de variable con función
          var location = e.geometry.coordinates.reverse(); // las geometrías
          location.push(3); // impulsadas
          return location; // devuelve el valor a location
          }); // se cierra la definición de la variable con función
        // definición de la clase heat layer definitiva
        var heatevento = L.heatLayer(locations, { radius: 10, blur: 15, minOpacity:0.2 }); // clase heat layer alimentada con radio,difuminación y opacidad
        myData.addLayer(heatevento);// se añade la capa heatcon previamente declarada y rellenada       
         myData.addTo(visor); // se añade el grupo de capas al mapa   
                }); // se cierra la petición sobre la capa evento
              }); // se cierra evento para botón eventos por mapa de calor
</script>
</html>